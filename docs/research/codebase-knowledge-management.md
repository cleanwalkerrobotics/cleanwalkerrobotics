# Codebase Knowledge Management for AI-Driven Multi-Team Development

**Date:** 2026-02-12
**Team:** cw-research
**Status:** Research complete — awaiting implementation decision

---

## Executive Summary

We need a system where AI sub-teams maintain awareness of what exists in the codebase to prevent duplicate work. After researching industry practices (Google, Meta, Uber, Spotify), AI-agent tooling (CLAUDE.md, Cursor rules, Aider repo maps, AGENTS.md), enforcement mechanisms, and anti-patterns, here is the recommended architecture:

**Build a three-layer system:**

1. **Auto-generated structural map** — A script that uses the filesystem and lightweight parsing to produce a compact `CODEBASE.md` at the repo root. Generated on every build, never hand-edited. Answers "what exists and where."
2. **Human-authored intent files** — Small `PURPOSE.md` files (3-10 lines) in each division root, describing what the division does, who owns it, and its boundaries. Answers "why this exists and what belongs here."
3. **Build-time enforcement** — CI and prebuild checks that validate the auto-generated map is current and PURPOSE.md files exist. No pre-commit hooks for metadata (they get bypassed).

This replaces the reverted per-file MANIFEST.md system (commit `4186be0`, reverted in `7dec516`) which failed because it required manual tracking of 211 individual files — an unsustainable maintenance burden.

**Key principle:** Auto-generate everything that can be derived from code. Only ask humans to write what cannot be inferred (purpose, ownership, architectural intent).

---

## 1. What Indicators Matter — Signal vs Noise

### High-Signal Metadata (worth tracking)

| Indicator | Why It Matters | Can Auto-Generate? |
|-----------|---------------|-------------------|
| **Module purpose** (1-line) | Prevents duplicate feature creation | No — requires human |
| **Owner team** | Routes questions, assigns reviews | No — requires human |
| **Module boundaries** (what belongs here) | Prevents misplaced files | No — requires human |
| **File inventory** (what exists) | The core discoverability need | Yes — filesystem scan |
| **Dependencies** (imports/exports) | Understanding module relationships | Yes — AST/import parsing |
| **Entry points** (main files, API routes) | Quick orientation for agents | Partially — heuristic |
| **Status** (active/WIP/deprecated) | Avoids building on unstable foundations | Partially — git activity heuristic |

### Low-Signal Metadata (noise — do not track)

| Indicator | Why It's Noise |
|-----------|---------------|
| **Per-file purpose** | Stale within days. Function names and code comments serve this role. |
| **Last-updated dates per file** | `git log` already provides this. Redundant data drifts. |
| **Test coverage percentages** | Changes every commit. Belongs in CI dashboards, not manifests. |
| **API surface details** | TypeScript types and function signatures are the source of truth. |
| **Line counts / complexity metrics** | Useful in dashboards, not in static documents. |

### The Lesson from Our Reverted MANIFEST.md

The reverted system tracked 211 individual files with per-file purpose, status, and updated dates. This is the "over-detailed manifest" anti-pattern identified in Spotify Backstage adoption data: organizations that mandate detailed metadata per file see initial compliance followed by rapid drift. Every new file requires a manifest update; every deleted file leaves a stale entry. The maintenance cost scales linearly with codebase size.

**What we actually need:** Teams need to know "there's a cost calculator demo at `apps/web/src/app/demos/cost-calculator/`" — not a purpose description for every `.tsx` file inside it.

---

## 2. Tree Structure Design

### Option A: Monolithic flat manifest (rejected)

A single `manifest.json` or `MANIFEST.md` at the root listing all files.

- **Pros:** Single source of truth, easy to search
- **Cons:** Merge conflicts when multiple teams edit simultaneously, grows unwieldy at 500+ files, no clear ownership

### Option B: Per-file manifests (rejected — already tried)

MANIFEST.md in each division listing every file.

- **Pros:** Division-level ownership, smaller files
- **Cons:** 211-file tracking burden, stale within weeks, already reverted from this repo

### Option C: Hierarchical auto-generated map + human intent files (recommended)

Two complementary layers:

**Layer 1 — Auto-generated `CODEBASE.md`** at repo root:
- Generated by a script that walks the filesystem
- Shows directory tree with file counts and key files
- Updated on every build — never edited by hand
- Injected into AI agent context as orientation

**Layer 2 — Human-authored `PURPOSE.md`** in each division root:
- 3-10 lines: what this division does, who owns it, what belongs here
- Reviewed in PRs when division boundaries change
- Stable enough to maintain manually (changes rarely)

**Why this works:**
- The auto-generated layer cannot drift (it reads the filesystem)
- The human layer is small enough that drift is noticeable and fixable
- Cross-cutting concerns (e.g., a sales doc referencing a demo) are handled by the auto-generated dependency/reference section, not manual cross-linking

### Handling Cross-Cutting Concerns

Cross-cutting references (sales docs mentioning demos, firmware referencing hardware specs) should NOT be manually tracked. Instead:

1. The auto-generated map shows what exists in each division
2. Teams consult the map before creating new features
3. If a team needs something from another division, they check that division's PURPOSE.md for boundaries and ownership
4. ADRs (Architecture Decision Records) in `docs/ceo/decisions-log.md` capture cross-division architectural choices

---

## 3. Efficient Maintenance — Keeping It Low-Friction

### The Maintenance Spectrum

```
Fully Manual          Hybrid              Fully Auto-Generated
(ADRs, PURPOSE.md)    (demo registry)     (CODEBASE.md, repo maps)
├─ Drifts fast        ├─ Moderate drift   ├─ Always current
├─ Rich semantics     ├─ Structured       ├─ Structural only
└─ Needs discipline   └─ Needs validation └─ Needs no action
```

### Recommended Maintenance Model

| What | How | Frequency | Who |
|------|-----|-----------|-----|
| `CODEBASE.md` | Auto-generated by `scripts/generate-codebase-map.mjs` | Every build | Script |
| `PURPOSE.md` files | Hand-written, reviewed in PRs | When division scope changes | Owning team |
| Demo registry | Existing `registry.json` system | When demos added/removed | cw-software |
| ADRs | `docs/ceo/decisions-log.md` | On architectural decisions | Any team, approved by Walker |
| Team log | `ops/team-log.md` | After every task completion | All teams |

### Auto-Generation Strategy

The `CODEBASE.md` generator should:

1. Walk the filesystem (excluding `node_modules`, `.next`, `target`, `dist`, `.git`)
2. For each division, list:
   - Directory structure (2 levels deep)
   - File count by extension
   - Key files (package.json, Cargo.toml, README, PURPOSE.md)
   - Recently modified files (from git, last 7 days)
3. Output compact Markdown optimized for LLM context windows
4. Target size: under 200 lines (fits in CLAUDE.md-style context injection)

### What If the Manifest Drifts?

With auto-generation, the structural map **cannot** drift — it is regenerated from the filesystem on every build. The only components that can drift are:

- **PURPOSE.md files** — Validated by CI (existence check, minimum content)
- **Demo registry** — Already validated by `check-demo-registry.mjs`
- **ADRs** — Not validated (acceptable; architectural decisions are inherently subjective)

If a PURPOSE.md becomes stale, the CI check ensures it at least exists. Detailed accuracy is enforced through PR review culture, not tooling — this is appropriate because purpose descriptions change rarely.

---

## 4. Prior Art — What Works at Scale

### Google: Code Search + OWNERS + BUILD

Google's approach is the gold standard but requires custom infrastructure:

- **Code Search** indexes 1.5 TB of code, processes 1M queries/day with <50ms latency
- **Kythe** provides cross-language semantic indexing (definitions, references, call graphs)
- **OWNERS files** per directory define review/approval authority
- **Bazel BUILD files** serve as both build config and module metadata
- Result: developers navigate the monorepo through search, not file browsing

**Applicable lesson:** Build files ARE the metadata. If the metadata is required for the build to succeed, it stays current. Our existing `package.json` + `turbo.json` + `Cargo.toml` already serve this role for build config. We should not duplicate this information.

### Meta: Buck2 + Starlark

Meta's Buck2 uses BUCK files per directory:

- Single incremental dependency graph (no build phases)
- 2x faster than Buck1 in internal benchmarks
- Language rules written in Starlark for extensibility

**Applicable lesson:** Even Meta's documentation is described as "overwhelming and confusing if you lack context to the Facebook way of doing things." Tool-centric discoverability works for build questions but fails for architectural understanding. We need both layers.

### Uber: Gazelle Auto-Generation

Uber's Go monorepo (70K+ files) uses Gazelle to auto-generate BUILD files from source code:

- Import statements determine dependencies automatically
- Generated files are NOT committed to source control
- Uber's monorepo strategy "nearly broke" before auto-generation was implemented

**Applicable lesson:** Manual manifest maintenance at scale is impossible. Auto-generation from the source of truth (the code itself) is the only sustainable path. Our CODEBASE.md should follow this pattern.

### Spotify Backstage: catalog-info.yaml

Backstage uses `catalog-info.yaml` files alongside code:

- Tracks ownership, metadata, dependencies, lifecycle stage
- Organizations typically achieve 80-90% coverage after focused effort
- However, adoption "often stalls at less than 10%" when not actively enforced
- A catalog at 50% completeness is worse than no catalog — you can't trust search results

**Applicable lesson:** Backstage's most effective strategy is connecting to deployment tools for auto-population, not asking developers to manually register. Minimizing human-authored metadata fields is critical.

### For Our Scale (<500 Files)

At our current scale (736 files, 5 divisions), the Google/Meta infrastructure is overkill. What works at our scale:

1. **Simple filesystem-based discovery** — A generated tree is sufficient, no need for search indexes
2. **Lightweight human metadata** — PURPOSE.md per division (5 files to maintain)
3. **Existing build validation** — Turborepo + demo registry checks already work
4. **CLAUDE.md hierarchy** — Already provides team-specific context injection

---

## 5. AI-Agent-Specific Considerations

### Context Window Constraints

Our AI sub-teams (Claude Code agents) have finite context windows. Every token of manifest data competes with actual code and instructions. The manifest must be:

- **Compact:** Under 200 lines for the full codebase map
- **Hierarchical:** Load division-specific detail only when working in that division
- **Scannable:** AI agents parse Markdown headers and tables efficiently
- **Non-redundant:** Don't repeat what's in CLAUDE.md or package.json

### The AGENTS.md / CLAUDE.md Ecosystem

The industry is converging on a standard for AI-readable codebase context:

| Tool | File | How It Loads |
|------|------|-------------|
| Claude Code | `CLAUDE.md` | Hierarchical: walks from CWD to root; lazy-loads subdirectory files |
| OpenAI Codex | `AGENTS.md` | Root-to-CWD traversal; 32 KiB combined limit |
| Cursor | `.cursor/rules/*.mdc` | Auto-attached by glob pattern |
| GitHub Copilot | `.github/copilot-instructions.md` | Per-repo; scoped `.instructions.md` with `applyTo` frontmatter |

**Key finding:** AGENTS.md is now stewarded by the Linux Foundation's Agentic AI Foundation, supported by 20+ tools including OpenAI, Google, Cursor, and Devin. Over 60K open-source projects use it.

**Recommendation:** We already use CLAUDE.md effectively. Adding an AGENTS.md at the root as a cross-tool alias is low-cost. The auto-generated CODEBASE.md should be referenced from CLAUDE.md so agents load it.

### Optimal Format for LLM Parsing

Research from Aider's repo map and Cursor's rules migration shows:

1. **Flat Markdown with clear headers** — Most universally parseable
2. **Tables for structured data** — Compact, scannable
3. **Keep individual files under 150 lines** — Longer files suffer "context dilution" where instructions at the end are followed less reliably
4. **Hierarchical loading** — Load the overview always; load division detail only when needed
5. **Avoid JSON for large manifests** — JSON is verbose and harder for LLMs to scan than Markdown tables

### Aider's Repo Map Approach

Aider uses tree-sitter to build a ranked symbol map:

1. Parse all source files into ASTs
2. Extract function/class definitions with signatures
3. Build a dependency graph from imports
4. Apply PageRank-like ranking to find most-referenced symbols
5. Send only top-ranked symbols within a token budget

**Applicable lesson:** On-demand generation is superior to stored manifests. The map is always current because it reads the code. However, Aider's approach requires tree-sitter infrastructure we don't currently have. Our simpler filesystem-based CODEBASE.md achieves 80% of the value at 20% of the complexity. Tree-sitter integration is a Phase 3 enhancement.

---

## 6. Enforcement — What Actually Works

### Enforcement Tiers

| Mechanism | Speed | Bypassable? | Best For |
|-----------|-------|-------------|----------|
| Pre-commit hooks | Must be <1s | Yes (`--no-verify`) | Auto-formatting, credential scanning |
| Pre-push hooks | Can be slower | Yes but rare | Linting, basic validation |
| Build-time validation | Part of build | No (build fails) | Module metadata, registry checks |
| CI required checks | PR-level | No (merge blocked) | Cross-module validation |
| CODEOWNERS | PR-level | No (review required) | Ownership enforcement |

### Recommended Enforcement for Our System

**DO enforce via build (prebuild script):**
- CODEBASE.md is current (regenerate and check for diff — if diff exists, the generated version IS the correct one, just needs committing)
- PURPOSE.md exists in each division root
- Demo registry is valid (existing check)

**DO enforce via CI:**
- All prebuild checks pass
- CODEBASE.md committed matches what the generator produces
- PURPOSE.md files have minimum content (not empty)

**DO NOT enforce via pre-commit:**
- Metadata validation in pre-commit hooks gets bypassed with `--no-verify`
- Slow hooks during rebase create cascading conflicts
- Pre-commit should only run formatters and credential scanners

**DO NOT enforce:**
- ADR completeness (architectural decisions are inherently judgment calls)
- Per-file documentation (unsustainable, as our MANIFEST.md experiment proved)
- Team log format (low-value enforcement; teams self-police)

### The "Build Fails" Principle

The most reliable enforcement is making the build depend on the metadata. If `CODEBASE.md` is stale, the prebuild script regenerates it and warns. If `PURPOSE.md` is missing, the build fails. This mirrors how our existing demo registry check works — unregistered demos fail the build, so teams always register them.

---

## 7. Anti-Patterns — What Sounds Good But Fails

### Anti-Pattern 1: Per-File Tracking (We Already Tried This)

Our reverted MANIFEST.md system tracked 211 individual files with purpose, status, and updated dates.

**Why it fails:** Maintenance scales linearly with file count. Every new file requires a manifest update. Every file deletion or rename leaves stale entries. The "updated" column is always wrong because nobody remembers to update it. Within weeks, the manifest becomes a liability — teams stop trusting it and stop maintaining it.

**Evidence:** Spotify Backstage data shows organizations requiring detailed per-component metadata plateau at 40-60% coverage and stay there. Incomplete catalogs are worse than none.

### Anti-Pattern 2: Monolithic Context Files

Single large instruction/context files (>150 lines) suffer from "context dilution" — LLMs follow instructions at the beginning more reliably than instructions at the end.

**Why it fails:** Cursor deprecated single `.cursorrules` in favor of split `.cursor/rules/*.mdc` files. Claude Code recommends keeping CLAUDE.md under 150 lines.

**Our mitigation:** CODEBASE.md is a generated overview (not instructions). Division-specific detail lives in PURPOSE.md files loaded only when relevant. Neither competes for instruction-following attention.

### Anti-Pattern 3: Redundant Metadata

Tracking information in a manifest that already exists in code (function signatures, dependency lists, export APIs).

**Why it fails:** Every redundant field is a future source of drift. Package.json already lists dependencies. Cargo.toml already lists crate metadata. TypeScript types already define the API surface. Duplicating this in a manifest creates two sources of truth that inevitably diverge.

**Our mitigation:** CODEBASE.md derives its data FROM these files, never duplicating. It shows "firmware/ has 3 Rust crates" — it doesn't list every function in those crates.

### Anti-Pattern 4: Wiki-Based Documentation (External to Repo)

Documentation in Confluence, Notion, or separate wikis.

**Why it fails:** Separated from the code change workflow. No enforcement mechanism. No PR review. No git history. Rapid drift is guaranteed because updating the wiki is a separate action from updating the code.

**Our mitigation:** Everything lives in the repo. CODEBASE.md, PURPOSE.md, ADRs, and CLAUDE.md are all in-repo, reviewed in PRs.

### Anti-Pattern 5: Enforcement Without Value

Mandatory metadata that blocks developers but provides no immediate benefit to the person filling it out.

**Why it fails:** Developers (and AI agents) treat it as a tax. They fill in minimum viable content ("TODO", "misc", "see code"). Pre-commit hooks get bypassed. CI checks get green-lit by adding boilerplate.

**Our mitigation:** The auto-generated CODEBASE.md provides immediate value (agents see what exists) with zero maintenance cost. PURPOSE.md is small enough (3-10 lines, rarely changes) that it doesn't feel like a tax.

### Anti-Pattern 6: Over-Granular Enforcement

Validating every metadata field for format, completeness, and accuracy.

**Why it fails:** False positives erode trust in the validation system. Developers learn to game the validator rather than provide meaningful metadata. The enforcement system itself becomes a maintenance burden.

**Our mitigation:** We only validate existence and minimum content, not semantic accuracy. A PURPOSE.md that says "Firmware division — Rust motor control and ROS2 integration" is validated as present and non-empty. Whether the description is perfectly accurate is a PR review concern, not a CI concern.

---

## Recommended Architecture

### Three-Layer System

```
┌─────────────────────────────────────────────────────────┐
│                    CODEBASE.md (auto-generated)          │
│  Generated by scripts/generate-codebase-map.mjs          │
│  Shows: directory tree, file counts, key files, recent   │
│  changes. Never hand-edited. ~150-200 lines.             │
│  Loaded into agent context via CLAUDE.md reference.       │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ PURPOSE.md  │    │ PURPOSE.md  │    │ PURPOSE.md  │  ...
│ (apps/web/) │    │ (firmware/) │    │ (ml/)       │
│ 3-10 lines  │    │ 3-10 lines  │    │ 3-10 lines  │
│ Human-      │    │ Human-      │    │ Human-      │
│ authored    │    │ authored    │    │ authored    │
└─────────────┘    └─────────────┘    └─────────────┘
                            │
                            ▼
              ┌──────────────────────────┐
              │ Existing Systems         │
              │ • demo registry.json     │
              │ • CLAUDE.md hierarchy    │
              │ • ADRs in decisions-log  │
              │ • team-log.md            │
              └──────────────────────────┘
```

### File Inventory

| File | Type | Maintained By | Location |
|------|------|--------------|----------|
| `CODEBASE.md` | Auto-generated structural map | Script | Repo root |
| `scripts/generate-codebase-map.mjs` | Generator script | cw-software | scripts/ |
| `apps/web/PURPOSE.md` | Division intent | cw-software | Division root |
| `firmware/PURPOSE.md` | Division intent | cw-hardware | Division root |
| `ml/PURPOSE.md` | Division intent | cw-research | Division root |
| `hardware/PURPOSE.md` | Division intent | cw-hardware | Division root |
| `docs/PURPOSE.md` | Division intent | Any team | Division root |
| `services/PURPOSE.md` | Division intent | cw-software | Division root |
| `packages/PURPOSE.md` | Division intent | cw-software | Division root |

### CODEBASE.md Format (Example)

```markdown
# CleanWalker Robotics — Codebase Map
<!-- AUTO-GENERATED by scripts/generate-codebase-map.mjs — DO NOT EDIT -->
<!-- Last generated: 2026-02-12T03:00:00Z -->

## Overview
736 tracked files across 7 divisions. Monorepo managed with pnpm + Turborepo.

## Divisions

### apps/web/ — Marketing Website
**Owner:** cw-software | **Stack:** Next.js 15, React 19, Tailwind CSS 4
**Files:** 113 | **Key:** package.json, next.config.ts

Routes: /, /about, /contact, /product, /pilot, /insights, /demos/*
Demos (9): 3d-robot-viewer, autonomous-ops, cost-calculator,
  fleet-dashboard, litter-detection, pick-and-compact,
  quadrupedal-locomotion, route-planning, simulation
Components: Navbar, HeroSection, Footer, ContactForm + 12 more

### firmware/ — Robot Firmware
**Owner:** cw-hardware | **Stack:** Rust, ROS2
**Files:** 379 | **Key:** Cargo.toml (workspace)

Crates: controller, motor-driver, comms
ROS2 packages: bringup, description, manipulation, navigation, perception

### ml/ — Machine Learning
**Owner:** cw-research | **Stack:** Python, PyTorch, YOLO
**Files:** 35 | **Key:** requirements.txt

Modules: perception (YOLO v8), locomotion (RL/PPO), training (TACO dataset)
PoC: replicate_detect.py

### hardware/ — Mechanical & PCB
**Owner:** cw-hardware | **Stack:** KiCad, URDF
**Files:** 19

Subsystems: mainboard, motor-driver-pcb, BOM
URDF: cleanwalker-cw1, unitree-go2 (reference)

### docs/ — Documentation
**Owner:** all teams | **Files:** 73

Categories: research (11), sales (16), ceo (10), design (2),
  technical (4), regulatory (1), market-research (9)

### services/api/ — Backend API
**Owner:** cw-software | **Stack:** Hono, TypeScript
**Files:** 32

### packages/ — Shared Libraries
**Owner:** cw-software | **Files:** 43

Packages: config, db (Drizzle), types, ui

## Recently Modified (last 7 days)
- apps/web/src/app/demos/ (demo registry update)
- docs/design/component-decisions.md (CW-1 decision matrix)
- firmware/src/ (motor control, gait, ROS2 bridge expansion)
```

### PURPOSE.md Format (Example)

```markdown
# apps/web — Purpose

Marketing website and interactive demos for CleanWalker Robotics.

**Owner:** cw-software
**What belongs here:** Pages, components, API routes, demo applications,
  static assets (renders, models), and web-specific configuration.
**What does NOT belong here:** Backend business logic (→ services/),
  shared types (→ packages/types/), documentation (→ docs/).
**Key constraint:** All demos must be registered in demos/registry.json.
```

---

## Implementation Plan (Phased)

### Phase 1: Foundation (1 session)

1. Create `scripts/generate-codebase-map.mjs`
   - Walk filesystem, collect directory stats
   - Parse package.json, Cargo.toml for metadata
   - Output compact Markdown to `CODEBASE.md`
   - Target: under 200 lines output

2. Create PURPOSE.md in each division root (7 files)
   - 3-10 lines each
   - Purpose, owner, boundaries

3. Add CODEBASE.md generation to prebuild
   - `"prebuild": "node scripts/generate-codebase-map.mjs && node scripts/check-demo-registry.mjs"`
   - Script generates CODEBASE.md; CI verifies it's committed

4. Update CLAUDE.md to reference CODEBASE.md
   - Add instruction: "Before creating new features, consult CODEBASE.md"

### Phase 2: Enforcement (1 session)

1. Add PURPOSE.md validation to prebuild
   - Check existence in each division root
   - Validate minimum content (non-empty, has "Owner:" field)

2. Add CI check for CODEBASE.md freshness
   - Regenerate in CI; diff against committed version
   - Fail if they diverge (means someone forgot to regenerate)

3. Add CODEOWNERS file
   - Map division directories to team owners
   - Require reviews from owning team for changes

### Phase 3: Enhancement (future, optional)

1. Add tree-sitter-based symbol extraction
   - Extract exported functions/types from TypeScript and Rust
   - Include top-level API surface in CODEBASE.md
   - Investigate Aider's repo map approach or RepoMapper MCP server

2. Add cross-reference detection
   - Scan for imports/references between divisions
   - Include dependency graph in CODEBASE.md

3. Evaluate AGENTS.md adoption
   - Add AGENTS.md at root as cross-tool alias for CLAUDE.md
   - Follow Linux Foundation's Agentic AI Foundation standard

### What NOT to Build

- Per-file manifests (already failed)
- External wikis or dashboards
- Complex metadata schemas with many required fields
- Pre-commit hooks for metadata validation
- Real-time sync between manifest and filesystem (just regenerate on build)

---

## Summary of Key Decisions

| Decision | Rationale |
|----------|-----------|
| Auto-generate structural map | Cannot drift; reads filesystem directly |
| Human-author only purpose/ownership | Only semantic metadata that code can't express |
| 3-10 line PURPOSE.md files | Small enough to maintain; stable enough to rarely change |
| Build-time enforcement, not pre-commit | Can't be bypassed; pre-commit hooks get `--no-verify`'d |
| Markdown format, not JSON/YAML | Most parseable by LLMs; compact; readable |
| Under 200 lines for CODEBASE.md | Fits in context window without dilution |
| No per-file tracking | Already tried and reverted (commit 4186be0) |
| Leverage existing systems | Demo registry, CLAUDE.md, ADRs, team-log already work |

---

## References

- Google SWE Book, Ch. 17 — Code Search: https://abseil.io/resources/swe-book/html/ch17.html
- Kythe cross-reference system: https://www.kythe.io/
- Uber's Go monorepo + Gazelle: https://www.uber.com/blog/go-monorepo-bazel/
- Spotify Backstage software catalog: https://backstage.io/
- Backstage catalog completeness strategies: https://roadie.io/blog/3-strategies-for-a-complete-software-catalog/
- AGENTS.md standard (Linux Foundation): https://agents.md/
- Aider repository map: https://aider.chat/2023/10/22/repomap.html
- Claude Code CLAUDE.md best practices: https://claude.com/blog/using-claude-md-files
- Cursor rules migration analysis: https://lellansin.github.io/2026/01/27/Why-Cursor-Rules-Failed-and-Claude-Skill-Succeeded/
- Pre-commit hooks criticism: https://jyn.dev/pre-commit-hooks-are-fundamentally-broken/
- Documentation debt in CI/CD: https://deepdocs.dev/why-ci-cd-still-doesnt-include-continuous-documentation/
- AI context file ecosystem survey: https://gist.github.com/0xdevalias/f40bc5a6f84c4c5ad862e314894b2fa6
